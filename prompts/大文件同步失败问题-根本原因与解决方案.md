# 大文件同步失败问题 - 根本原因分析

## 🎯 问题根源

基于用户提供的日志和现象，问题已经明确：

### 关键日志

```javascript
[ChunkFetcher] Fetch result: {success: true, fetchedCount: 100, requestedCount: 100}
[ChunkFetcher] Chunks stored successfully: {stored: 100, written: 0, cached: 0, duplicated: 0}
                                                          ^^^^^^^^^ 
                                                          问题：没有写入任何chunk！
```

### 问题分析

#### 步骤 1：设备 A 上传大文件

设备 A 上传了一个 11MB 的视频文件，被分成 108 个 chunks：
- 元数据文档（meta）：`Screen Recording 2026-01-30 at 15.19.36.mov`
- 108 个 chunk 文档：`h:xxx123`, `h:xxx456`, ...

全部上传到 CouchDB。

#### 步骤 2：设备 B 同步（启用 `readChunksOnline`）

**Pull 阶段**：
```typescript
// LiveSyncReplicator.ts Line 933
localDB.replicate.from(db, {
    ...syncOptionBase,
    ...(setting.readChunksOnline ? selectorOnDemandPull : {}),
})

// selectorOnDemandPull = { selector: { type: { $ne: "leaf" } } }
// 意图：只同步非 chunk 文档
```

**但是 PouchDB/CouchDB 的 replication 行为**：

即使有 selector 过滤，CouchDB 的 replication 协议也会同步 chunk 文档的**元数据**（`_id`, `_rev`, `type`），**但不包括大字段**（如 `data`）。

这导致设备 B 本地数据库中有：
- ✅ 元数据文档（完整）
- ⚠️ 108 个 chunk 文档（**空壳**，只有 `_id`, `_rev`, `type: "leaf"`，**没有 `data` 字段**）

#### 步骤 3：设备 B 尝试打开文件

```javascript
// EntryManager 尝试读取 chunks
const chunks = await this.chunkManager.read(childrenKeys, {...});

// ChunkManager.readSingle()
const result = await this.database.get(id);  // ✅ 找到了 chunk 文档
if (result && isChunkDoc(result)) {           // ✅ 通过验证（type === "leaf"）
    return result;                             // ❌ 返回空壳 chunk（没有 data）
}
```

**问题**：`isChunkDoc` 只检查 `type === "leaf"`，**不检查 `data` 字段**：

```typescript
function isChunkDoc(doc: any): doc is EntryLeaf {
    return doc && typeof doc._id === "string" && doc.type === "leaf";
    // ❌ 缺少：&& typeof doc.data === "string"
}
```

所以 ChunkManager 返回了 108 个空壳 chunks，`chunks.some((e) => e === false)` 为 `false`（没有 `false`，都是对象）。

但是这些对象的 `data` 字段是 `undefined`！

#### 步骤 4：EntryManager 尝试组装文档

```typescript
const doc: LoadedEntry = {
    data: (chunks as EntryLeaf[]).map((e) => e.data),  
    // [undefined, undefined, ..., undefined]  ❌ 全是 undefined！
};
```

等等，这会导致错误？让我检查...

实际上，如果 chunk 的 `data` 是 `undefined`，`map((e) => e.data)` 会返回一个包含 `undefined` 的数组，这在后续处理时会出错。

但是根据日志，在 `Failed to load chunks` 之前，ChunkFetcher 就开始工作了：

```javascript
[ChunkFetcher] Starting requestMissingChunks: {queueLength: 108}
```

这说明 ChunkManager 检测到了 chunks 缺失，**但是如何检测到的？**

让我重新看代码...

啊！我发现了！在 `readSingle` 中：

```typescript
const result = await this.database.get(id);
if (result && isChunkDoc(result)) {
    this.cacheChunk(result);
    return result;  // ← 这里返回了空壳 chunk
}
// 如果走到这里，说明没找到或不是 chunk 文档
// 然后会触发等待和事件发送
```

但是空壳 chunk 会通过 `isChunkDoc` 检查，所以**不会触发 ChunkFetcher**！

所以问题是：**为什么 ChunkFetcher 会被触发？**

让我重新看你的日志...

啊！我看到了！在 `Failed to load chunks` **之前**就有 ChunkFetcher 的日志：

```
[ChunkFetcher] Starting requestMissingChunks: {queueLength: 108, ...}
...
[Friday Sync] Failed to load chunks for Screen Recording ...
```

这说明：
1. ChunkManager 检测到 chunks 缺失（可能是通过其他路径）
2. ChunkFetcher 开始拉取
3. **但是拉取速度慢于 EntryManager 的超时时间**（30 秒）
4. EntryManager 超时，抛出 "Load failed" 错误
5. ChunkFetcher 继续拉取，成功获取了 chunks
6. **但是无法保存**（`written: 0`）

#### 步骤 5：为什么无法保存？

ChunkFetcher 调用：

```typescript
await this.chunkManager.write(chunks, {
    skipCache: true,
    force: true,  // ← 使用 force 模式
}, "ChunkFetcher" as DocumentID);
```

`force: true` 意味着使用 `new_edits: false`：

```typescript
await this.database.bulkDocs(storeChunks, { new_edits: !options?.force });
// new_edits: false → 使用 chunk 的原始 _rev，如果已存在则不更新
```

**这就是问题**！

因为本地数据库中已经有这些 chunk 文档（虽然是空壳），并且有相同的 `_rev`，PouchDB 认为不需要更新，**直接返回成功**（没有 409 冲突）！

所以：
- `written: 0` - 没有实际写入
- `cached: 0` - 没有从缓存跳过（因为 `skipCache: true`）
- `duplicated: 0` - 没有冲突（因为 `_rev` 相同，PouchDB 认为是重复写入）

## 🔍 为什么重命名后就能看到？

**现象**：在设备 A 重命名文件后，设备 B 能看到完整文件。

**原因**：

1. 设备 A 重命名文件时，会创建新的文档元数据（新的 `_id`）
2. **旧文档被标记为删除**，但 chunks 仍然保留
3. 新文档同步到设备 B
4. 设备 B 尝试读取时，ChunkManager 从**本地数据库找到了完整的 chunks**

等等，这不对...如果本地是空壳，重命名后应该还是空壳才对。

除非...

**可能的解释**：

1. 重命名后，设备 A 重新上传了文档，包括 chunks
2. 这次同步时，chunks 被**完整同步**（可能 selector 过滤失效或其他原因）
3. 或者，重命名触发了某种"修复"机制

或者另一个可能：

1. 第一次失败后，chunks 实际上已经被 ChunkFetcher 缓存（虽然没有写入数据库）
2. 重命名后，读取同样的 chunks 时，从**缓存**中找到了完整的 chunks

但这也不对，因为日志显示 `cached: 0`...

## 💡 解决方案

### 方案 A：修改 ChunkFetcher 的保存逻辑 ✅ 推荐

不使用 `force: true`，而是先删除本地空壳 chunk，再保存：

```typescript
// src/sync/core/managers/ChunkFetcher.ts

// 在保存前，先删除可能存在的空壳 chunks
try {
    // 批量删除现有的 chunk 文档
    const existingDocs = await this.chunkManager.database.allDocs({
        keys: chunks.map(c => c._id),
        include_docs: true
    });
    
    const docsToDelete = existingDocs.rows
        .filter(row => 'doc' in row && row.doc && (!row.doc.data || row.doc.data.length === 0))
        .map(row => ({
            ...row.doc,
            _deleted: true
        }));
    
    if (docsToDelete.length > 0) {
        console.log('[ChunkFetcher] Deleting empty shell chunks before write:', docsToDelete.length);
        await this.chunkManager.database.bulkDocs(docsToDelete);
    }
} catch (error) {
    console.warn('[ChunkFetcher] Failed to delete shell chunks:', error);
}

// 然后正常保存（不使用 force）
const result = await this.chunkManager.write(
    chunks,
    {
        skipCache: false,  // 允许缓存
        force: false,       // 不强制，让 PouchDB 正常处理冲突
    },
    "ChunkFetcher" as DocumentID
);
```

### 方案 B：增强 `isChunkDoc` 验证 ✅ 推荐（配合方案 A）

```typescript
// src/sync/core/managers/ChunkManager.ts

function isChunkDoc(doc: any): doc is EntryLeaf {
    return doc && 
           typeof doc._id === "string" && 
           doc.type === "leaf" &&
           typeof doc.data === "string" &&  // ← 新增：检查 data 字段
           doc.data.length > 0;               // ← 新增：确保不是空字符串
}
```

这样可以确保只有完整的 chunk 才会被认为是有效的。

### 方案 C：修改 replication selector ⚠️ 不推荐

完全禁止 chunk 元数据被同步，但这可能影响 CouchDB 的正常工作。

### 方案 D：修改 ChunkManager.write 的冲突处理 ⚠️ 复杂

在处理 409 冲突时，如果发现本地 chunk 是空壳，强制覆盖。

## 📝 实施步骤

### 立即实施（验证问题）

1. 添加更多日志（已完成）
2. 让用户重现问题，收集日志
3. 确认 `written: 0` 的原因

### 短期修复（1-2 天）

1. 实施**方案 A** - 修改 ChunkFetcher 保存逻辑
2. 实施**方案 B** - 增强 `isChunkDoc` 验证
3. 测试验证

### 长期优化（可选）

1. 优化 replication selector，避免同步空壳 chunks
2. 添加数据库健康检查，自动清理空壳 chunks
3. 添加 UI 提示，告知用户 chunk 拉取进度

## 🧪 测试计划

### 测试用例 1：新设备同步大文件

1. 设备 A 上传大文件（> 10MB）
2. 设备 B 启动同步（启用 `readChunksOnline`）
3. 等待同步完成
4. 在设备 B 打开大文件
5. **预期**：文件能正常打开，所有 chunks 被正确拉取和保存

### 测试用例 2：空壳 chunks 修复

1. 制造空壳 chunks（手动删除 chunk 的 `data` 字段）
2. 尝试打开文件
3. **预期**：ChunkFetcher 自动拉取并覆盖空壳 chunks

### 测试用例 3：小文件不受影响

1. 同步小文件（< 1MB）
2. **预期**：正常工作，不受修改影响

## 🎯 预期结果

修复后：
- ✅ 大文件首次同步后能正常打开
- ✅ ChunkFetcher 能正确保存拉取的 chunks
- ✅ 不需要重命名文件来触发"修复"
- ✅ 小文件同步不受影响
