# 大文件同步失败问题分析与解决方案

## 问题现象

同步大文件（如 `sync-theme.mov`，17MB）时出现 171/171 chunks 全部丢失的错误：

```
[Friday Sync] Failed to load chunks for sync-theme.mov: 
{failedChunkIds: Array(171), totalChunks: 171, failedCount: 171}

[Friday Sync] Error reading sync-theme.mov from database: 
{error: Error: Load failed: 171/171 chunks missing}

[Friday Sync] Could not get full entry for: 
{docId: 'sync-theme.mov', docPath: 'sync-theme.mov', docType: 'newnote', docSize: 17487157, docChildren: 171}
```

## 根本原因分析

### 1. **Fetch Chunks on Demand 机制缺失**

#### LiveSync 的实现

LiveSync 有一个关键的 `readChunksOnline` (Fetch chunks on demand) 功能：

**位置**: `livesync/src/modules/core/ReplicateResultProcessor.ts:380-388`

```typescript
// If `Read chunks online` is disabled, chunks should be transferred before here.
// However, in some cases, chunks are after that. So, if missing chunks exist, we have to wait for them.
// (If `Use Only Local Chunks` is enabled, we should not attempt to fetch chunks online automatically).

const isDeleted = dbDoc._deleted === true || ("deleted" in dbDoc && dbDoc.deleted === true);
// Gather full document if not deleted
const doc = isDeleted
    ? { ...dbDoc, data: "" }
    : await this.localDatabase.getDBEntryFromMeta({ ...dbDoc }, false, true);
```

**关键配置**: `livesync/src/lib/src/replication/couchdb/LiveSyncReplicator.ts:933`

```typescript
// Pull 模式下，如果启用了 readChunksOnline，则只同步非 chunk 文档
localDB.replicate.from(db, {
    ...syncOptionBase,
    ...(setting.readChunksOnline ? selectorOnDemandPull : {}),
})

// selectorOnDemandPull 定义
const selectorOnDemandPull = { selector: { type: { $ne: "leaf" } } };
```

**工作流程**:
1. **Pull 阶段**: 如果 `readChunksOnline=true`，只同步文档元数据（meta），不同步 chunks（通过 selector 过滤 `type: "leaf"`）
2. **读取阶段**: 当需要读取文件内容时，通过 `getDBEntryFromMeta(..., waitForReady=true)` 触发按需获取
3. **ChunkManager 等待机制**: 如果 chunk 不存在，ChunkManager 会等待 chunk 到达（超时时间 15-30 秒）
4. **ChunkFetcher 自动拉取**: 监听 `EVENT_MISSING_CHUNKS` 事件，自动从远程数据库拉取缺失的 chunks

#### 我们的实现

**位置**: `src/sync/core/replication/couchdb/LiveSyncReplicator.ts:931-933`

```typescript
// 我们也有相同的 selector 逻辑
localDB.replicate.from(db, {
    ...syncOptionBase,
    ...(setting.readChunksOnline ? selectorOnDemandPull : {}),
})
```

**但是缺少**:
1. ✅ **有**: ChunkManager 的等待机制（`LEAF_WAIT_TIMEOUT = 30000ms`）
2. ✅ **有**: ChunkManager 发出 `EVENT_MISSING_CHUNKS` 事件
3. ❌ **缺**: ChunkFetcher 来响应事件并自动拉取 chunks
4. ❌ **缺**: 从远程数据库按需拉取 chunks 的实现

### 2. **ChunkFetcher 机制对比**

#### LiveSync 的 ChunkFetcher

虽然 livesync 的新版本重构了代码，但从注释和更新日志可以看出关键机制：

**从 `updates_old.md` 中的说明**:

```markdown
- Fetching chunks on demand is now handled separately from the `ChunkManager` 
  and chunk reading functions. Chunks are queued by the `ChunkManager` and 
  then processed by the `ChunkFetcher`, simplifying the process and reducing 
  unnecessary complexity.
```

**从 `updates.md` 中的行为变化**:

```markdown
- The plug-in automatically fetches the missing chunks even if 
  `Fetch chunks on demand` is disabled.
  - This change is to avoid loss of data when receiving a bulk of revisions.
  - This can be prevented by enabling `Use Only Local Chunks` in the settings.
```

**关键点**:
- ChunkFetcher 监听 `EVENT_MISSING_CHUNKS` 事件
- 自动从远程数据库批量拉取缺失的 chunks
- 即使 `readChunksOnline=false` 也会自动拉取（防止数据丢失）

#### 我们的实现

**ChunkManager 代码**: `src/sync/core/managers/ChunkManager.ts:328-332`

```typescript
// 我们确实发出了事件
if (timeout > 0) {
    const ret = this._enqueueWaiting(id, timeout);
    if (!options.preventRemoteRequest) {
        this.emitEvent(EVENT_MISSING_CHUNKS, [id]); // ✅ 发出事件
    }
    return ret;
}
```

**但是**: 没有任何监听器来处理这个事件！

搜索代码：
```bash
# 在我们的代码中
$ grep -r "EVENT_MISSING_CHUNKS" src/
src/sync/core/managers/ChunkFetcher.ts:export const EVENT_MISSING_CHUNK_REMOTE = "missingChunkRemote";
src/sync/core/managers/ChunkFetcher.ts:export const EVENT_MISSING_CHUNKS = "missingChunks"; // ✅ 定义了
src/sync/core/managers/ChunkManager.ts:import { EVENT_MISSING_CHUNK_REMOTE, EVENT_MISSING_CHUNKS } from "./ChunkFetcher.ts";
src/sync/core/managers/ChunkManager.ts:    [EVENT_MISSING_CHUNKS]: DocumentID[]; // Event for multiple missing chunks
src/sync/core/managers/ChunkManager.ts:        this.emitEvent(EVENT_MISSING_CHUNKS, [id]); // ✅ 发出了事件

# ❌ 但没有找到 addListener(EVENT_MISSING_CHUNKS, ...) 的代码！
```

### 3. **大文件同步失败的完整流程**

1. **设备 A** 上传大文件：
   - 文件被分成 171 个 chunks
   - Chunks 和文档元数据都被上传到 CouchDB

2. **设备 B** 开始同步（`readChunksOnline=true`）：
   - Pull 阶段：只同步文档元数据（meta），跳过 171 个 chunks
   - 此时本地数据库中：
     - ✅ 有：文档元数据（`sync-theme.mov`）
     - ❌ 缺：171 个 chunks

3. **用户试图访问文件**：
   - 调用 `getDBEntryFromMeta(meta, false, true)` 读取文件
   - ChunkManager 尝试读取 171 个 chunks
   - 所有 chunks 都返回 `false`（本地不存在）
   - ChunkManager 发出 `EVENT_MISSING_CHUNKS` 事件
   - **ChunkFetcher 不存在** → 没有人响应事件
   - 30 秒超时后，返回 `false`
   - 抛出错误：`Load failed: 171/171 chunks missing`

## 解决方案

### 方案 A：实现 ChunkFetcher（推荐，完整方案）

模仿 LiveSync 实现一个完整的 ChunkFetcher 机制。

**优点**:
- 完整解决大文件同步问题
- 支持按需拉取，节省带宽和存储
- 用户体验好（无需等待全量同步）

**缺点**:
- 实现复杂度较高
- 需要处理并发、批量、错误重试等

**关键组件**:

1. **ChunkFetcher 类**（需要新建）:
   ```typescript
   class ChunkFetcher {
       private remoteDB: PouchDB.Database;
       private localDB: PouchDB.Database;
       private chunkManager: ChunkManager;
       private queue: DocumentID[] = [];
       
       constructor() {
           // 监听缺失 chunk 事件
           this.chunkManager.addListener(EVENT_MISSING_CHUNKS, (chunkIds) => {
               this.enqueueChunks(chunkIds);
           });
       }
       
       private async enqueueChunks(chunkIds: DocumentID[]) {
           this.queue.push(...chunkIds);
           await this.processBatch();
       }
       
       private async processBatch() {
           // 批量从远程数据库拉取 chunks
           const batch = this.queue.splice(0, 50); // 每次处理 50 个
           const docs = await this.remoteDB.allDocs({
               keys: batch,
               include_docs: true
           });
           
           // 保存到本地数据库
           const chunks = docs.rows
               .filter(row => 'doc' in row)
               .map(row => row.doc);
           await this.localDB.bulkDocs(chunks, { new_edits: false });
           
           // 通知 ChunkManager chunk 已到达
           chunks.forEach(chunk => {
               this.chunkManager.onChunkArrived(chunk);
           });
       }
   }
   ```

2. **集成到 Replicator**:
   ```typescript
   class LiveSyncCouchDBReplicator {
       private chunkFetcher?: ChunkFetcher;
       
       async openContinuousReplication() {
           // 启动 chunk fetcher
           if (this.settings.readChunksOnline) {
               this.chunkFetcher = new ChunkFetcher(
                   this.remoteDB,
                   this.localDB,
                   this.chunkManager
               );
           }
       }
   }
   ```

### 方案 B：禁用 readChunksOnline，全量同步（临时方案）

在设置中强制 `readChunksOnline=false`，让所有 chunks 在 Pull 阶段就同步下来。

**优点**:
- 实现简单，立即可用
- 100% 保证数据完整性

**缺点**:
- 首次同步时间长
- 占用更多本地存储
- 浪费带宽（同步不需要的历史版本的 chunks）

**实现**:
```typescript
// src/sync/core/replication/couchdb/LiveSyncReplicator.ts
async openOneShotReplication() {
    // 临时禁用 readChunksOnline
    const syncOptionBase = {
        ...options,
        // 移除 selector，让 chunks 也被同步
    };
    
    const syncHandler = localDB.replicate.from(db, syncOptionBase);
}
```

### 方案 C：手动拉取缺失 chunks（中间方案）

在 `getDBEntryFromMeta` 检测到 chunks 缺失时，手动从远程拉取。

**优点**:
- 不需要实现完整的 ChunkFetcher
- 能解决问题

**缺点**:
- 性能不如方案 A（每次读取都可能触发网络请求）
- 代码侵入性强
- 需要传递 remoteDB 引用到 EntryManager

**实现**:
```typescript
// src/sync/core/managers/EntryManager/EntryManager.ts
async getDBEntryFromMeta(meta: LoadedEntry, dump = false, waitForReady = true) {
    const chunks = await this.chunkManager.read(childrenKeys, {...});
    
    if (chunks.some((e) => e === false)) {
        // 检测到缺失，尝试从远程拉取
        const missingIds = chunks
            .map((e, i) => e === false ? childrenKeys[i] : null)
            .filter(id => id !== null);
            
        if (this.remoteDB && this.settings.readChunksOnline) {
            await this.fetchChunksFromRemote(missingIds);
            // 重试读取
            const chunksRetry = await this.chunkManager.read(childrenKeys, {...});
            if (!chunksRetry.some((e) => e === false)) {
                // 成功拉取，继续处理
                return this.buildLoadedEntry(chunksRetry, meta);
            }
        }
        
        // 仍然失败，抛出错误
        throw new Error(`Load failed: ${failedCount}/${totalChunks} chunks missing`);
    }
}
```

## 推荐实施路线

### 阶段 1：临时修复（1-2 天）
实施**方案 B**，确保用户不会遇到数据丢失问题。

### 阶段 2：完整实现（1-2 周）
实施**方案 A**，提供完整的 ChunkFetcher 机制：
1. 实现 ChunkFetcher 类
2. 集成到 Replicator 生命周期
3. 添加批量拉取、错误重试、并发控制
4. 添加单元测试

### 阶段 3：优化（可选）
- 实现 chunk 预取（预测用户可能访问的文件）
- 实现 chunk 缓存策略（LRU）
- 添加网络状况自适应（弱网环境下的降级策略）

## 相关文件

### 需要查看的 LiveSync 源码
- `livesync/src/modules/core/ReplicateResultProcessor.ts` - 文档处理流程
- `livesync/src/lib/src/replication/couchdb/LiveSyncReplicator.ts` - 复制逻辑
- `livesync/src/lib/src/managers/ChunkManager.ts` - Chunk 管理（如果存在）
- `livesync/updates.md` & `livesync/updates_old.md` - 功能变更说明

### 需要修改的我们的文件
- `src/sync/core/managers/ChunkManager.ts` - 已有的 ChunkManager
- `src/sync/core/managers/ChunkFetcher.ts` - **需要新建或完善**
- `src/sync/core/replication/couchdb/LiveSyncReplicator.ts` - 集成 ChunkFetcher
- `src/sync/core/managers/EntryManager/EntryManager.ts` - 错误处理优化

## 验证测试

### 测试场景
1. **小文件同步**（< 1MB）
   - 应该正常工作，无论是否启用 readChunksOnline

2. **大文件同步**（> 10MB）
   - 设备 A 上传大文件
   - 设备 B 同步并能够正常打开文件
   - 检查本地数据库中 chunks 是否正确拉取

3. **并发访问**
   - 多个大文件同时需要 chunks
   - ChunkFetcher 应该能够批量处理

4. **网络故障恢复**
   - 模拟网络中断
   - ChunkFetcher 应该能够重试

### 测试指标
- ✅ Chunks 成功拉取率 > 99%
- ✅ 大文件（10MB+）首次访问延迟 < 5 秒
- ✅ 批量操作效率（50 个 chunks 批量拉取 < 2 秒）

## 总结

问题的核心在于：**我们实现了 ChunkManager 的等待机制和事件发出，但没有实现 ChunkFetcher 来响应事件并自动拉取缺失的 chunks。**

LiveSync 通过 `readChunksOnline` + `ChunkFetcher` 的组合，实现了一个完整的按需拉取机制，我们需要补齐 ChunkFetcher 这一环。
